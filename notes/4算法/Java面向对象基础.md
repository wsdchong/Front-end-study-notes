两个部分：一是理论、二是实践；

这里的Java讲解来源于2010年之前，之后的改变看官网。

Java的基本使用：https://blog.csdn.net/weixin_42875245/article/details/105939720

Java应用基础：https://blog.csdn.net/weixin_42875245/article/details/105939796



## 一、抽象和封装

1所有编程语言都有抽象的功能。汇编语言对机器语言进行了抽象，过程化语言对汇编语言进行抽象，面向对象方法在过程化语言进行了抽象。

对象是现实世界的实体或概念在计算机逻辑中的抽象表示。面向对象语言更加贴近人的思维方式。使项目可控制、可维护；

2封装是一种组织软件的方法。其基本思想是把客观世界中联系紧密的元素及相关操作组织在一起，使其相互关系隐藏在内部，而对外仅仅表现为与其他封装体间的接口。从而构建出具有独立含义的软件实现。

在面向对象的程序设计中提出了一种全新的封装方法-类。每个类都封装了相关的数据和操作。类的封装特性使得类可重用性大大提高



## 二、类

1Java中的类有系统定义的类（类库、包）和用户定义的类。类包括成员变量和成员方法两部分。

类的成员变量可以使基本数据类型的数据，也可以使一个类的实例；

类的方法用于处理该类的数据。

2格式：

修饰符 class 类名 extends 父类 implements 接口 {变量定义和初始化；方法定义及方法体}



## 三、类的修饰符

1属性的访问权限有public、private、默认（package）

使用私有属性和公有方法可以保护数据，是代码维护性好；操作：使用private修饰符修饰属性，对象外部就不能直接访问这些属性，除非使用类内方法访问。

2非访问控制符：

Abstract：定义一个抽象类，使其子类来继承它定义的属性和方法，避免子类重复定义；定义一个抽象方法，为该类子类定义一个方法的接口标准，方法的具体实现在子类中完成。提高重用性

Final：定义最终类，该类不能被继承，不能再有子类。可以杜绝其子类的产生，将该类的属性和方法固定下来，类的内容与类的引用形成稳定的映射关系。提高可维护性。

Java采用单重基础机制，每个类只有一个父类

抽象方法在非抽象类中必须实现，最终方法不能被重新定义（覆盖）



## 四、方法

1类方法定义规则

修饰符 返回类型 方法名（参数列表）{方法定义}

方法名后的小括号是方法的标志；在方法中定义的变量为局部变量，局部变量使用前必须初始化，从进入方法体建立到退出方法时撤销。

方法名相同，参数不同，是不同的方法；与类名相同的所有方法都是类的构造方法。

2this

只能在方法使用，表示当前对象；适用于一些特殊场合。

为了解决实例变量和局部变量之间的命名冲突。

3重载

用用一个名字来表示不同的方法。利用重名现象可以提高程序的抽象度和简洁性。

方法名必须相同，方法的参数必须不同，返回类型可以不同（但不是重载的标志）

4构造方法

类名 对象引用名 = new 构造方法（）；

New运算符的参数是调用类的构造方法，用来初始化新建的对象。New运算符为对象分配内存空间，并返回该对象的一个引用。

构造方法的名字必须是类的名字；



## 五、继承

1新类必须在已有类的基础上构造，父类派生子类，子类继承父类；

继承是面向对象程序设计的基石之一，体现了软件的复用。

子类继承父类所有属性和方法（除private），但不继承构造方法。子类需要自己定义自己的构造方法。

为保证安全性，子类的所有构造方法中，必须首先调用一个父类的构造方法。在AOP编程时，可以用控制反转IOC来依赖注入DI。

子类可以在自己的构造方法中使用super（）来调用父类带参数的构造方法，但该语句必须第一个执行。

重载：一个类中，同名方法（参数不同）；

覆盖：子类对父类方法的覆盖（不同类的同名方法）

接口：抽象方法的集合。无法被实例化。



## 六、编程

1实现继承

2实现封装

3使用接口

https://blog.csdn.net/weixin_42875245/article/details/105939126



遇到的问题

1在我创建一个类后，报错

The abstract method getInfo in type Person can only be defined by an abstract class

原因是没创建一个抽象类，一个在创建类的时候，勾选abstract；

在创建继承类的时候，在superclass那里输入父类，然后创建。；



2 The method addCourse(Course) is undefined for the type Student

原因是没分析出来，我明明在student类定义了，全英文状态，没写错。没办法，我再按顺序再写一次。

顺便了解到@override的作用。它是伪代码，代表重写。写下的好处是：1可以当注释用，方便阅读，2编译器可以检验@override下的方法名是否是父类所有，如果没有就报错。如果不写这个的话，下面方法名错了，编译器任然可以运行，但是会把这个方法算作子类自己的方法。



3发现运行的时候没有application。

百度后，发现，在类里我没定义程序的入口main方法。

于是我就在那个类里加这个入口，然后新建student，想去使用，但是报错说student没定义。迷。





总结：梳理了一下Java的面向对象基础（抽象、封装、类），然后运行一下教务系统。

下一阶段，梳理一下图形用户界面的设计与实现。然后做一个计算器。



总结：梳理了一下Java的面向对象基础（抽象、封装、类），然后运行一下教务系统。

下一阶段，梳理一下图形用户界面的设计与实现。然后做一个计算器。